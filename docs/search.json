[
  {
    "objectID": "presentacion.html#sobre-este-taller",
    "href": "presentacion.html#sobre-este-taller",
    "title": "Desarrollando Software en Comunidad",
    "section": "Sobre este taller",
    "text": "Sobre este taller\n\n\n\nPor qué usar git\nCómo usar git (y GitHub)\nCómo trabajar con git en el contexto de escribir código R\nCómo colaborar con otras personas."
  },
  {
    "objectID": "presentacion.html#ciclo-del-control-de-versiones",
    "href": "presentacion.html#ciclo-del-control-de-versiones",
    "title": "Desarrollando Software en Comunidad",
    "section": "Ciclo del control de versiones",
    "text": "Ciclo del control de versiones\n\nLa figura muestra los estados de un archivo: sin rastrear o rastreado. Cuando es rastreado por el repositorio, el archivo puede ser preparado, confirmado o modificado. Con la acción «add, añadir», el archivo se «prepara, staged», y con la acción «commit, confirmar», el archivo se «guarda» en el repositorio. Este ciclo se repite cada vez que se modifica el archivo."
  },
  {
    "objectID": "presentacion.html#nuestro-flujo-de-trabajo",
    "href": "presentacion.html#nuestro-flujo-de-trabajo",
    "title": "Desarrollando Software en Comunidad",
    "section": "Nuestro flujo de trabajo",
    "text": "Nuestro flujo de trabajo\n\nModelo conceptual de un flujo de trabajo utilizando proyectos de RStudio y git. Los archivos se añaden al área de preparación y a continuación se envían al repositorio local. Puede enviar los cambios al repositorio remoto y descargar los nuevos cambios a su ordenador."
  },
  {
    "objectID": "presentacion.html#chequear-que-todo-esta-listo",
    "href": "presentacion.html#chequear-que-todo-esta-listo",
    "title": "Desarrollando Software en Comunidad",
    "section": "Chequear que todo esta listo",
    "text": "Chequear que todo esta listo\n&gt; usethis::git_sitrep()\n\n── Git global (user) \n• Name: \"Pao Corrales\"\n• Email: \"micorreo@gmail.com\"\n• Global (user-level) gitignore file: ~/.gitignore\n• Vaccinated: TRUE\n• Default Git protocol: \"https\"\n• Default initial branch name: \"main\"\n\n── GitHub user \n• Default GitHub host: \"https://github.com\"\n• Personal access token for \"https://github.com\": &lt;discovered&gt;\n• GitHub user: \"paocorrales\"\n• Token scopes: \"gist\", \"repo\", \"user\", and \"workflow\"\n• Email(s): \"micorreo@gmail.com (primary)\", \"paocorrales@users.noreply.github.com\", and\n  \"otro correo@gmail.com\"\nℹ No active usethis project."
  },
  {
    "objectID": "presentacion.html#usando-git-y-github-con-rstudio",
    "href": "presentacion.html#usando-git-y-github-con-rstudio",
    "title": "Desarrollando Software en Comunidad",
    "section": "Usando git y GitHub con RStudio",
    "text": "Usando git y GitHub con RStudio\nSupongamos que ya tenes un proyecto de RStudio y queres empezar a usar git y GitHub:\n\nCrea un nuevo proyecto de RStudio\n\nFile \\&gt; New Project \\&gt; New Directory \\&gt; New Project. No selecciones la opcion “Create a new git repository”.\n\nUsa usethis::use_git() para asegurarte que el proyecto tiene un repositorio git.\nUsa la funcion usethis::use_github() para asociar el repositorio local con un repositorio remoto en GitHub.\nChequea en tu GitHub que el nuevo repo con el nombre del proyecto exista."
  },
  {
    "objectID": "presentacion.html#confirmar-cambios-locales",
    "href": "presentacion.html#confirmar-cambios-locales",
    "title": "Desarrollando Software en Comunidad",
    "section": "Confirmar cambios locales",
    "text": "Confirmar cambios locales\n\nCreá un nuevo archivo RMarkdown y guardalo.\nAgregalo al área de preparación con add y luego hace un commit. ¡Vas a tener que pensar un mensaje descriptivo!\nHace un cambio en el archivo, puede ser cualquier cosa. Guardalo.\nRepetí el paso 2.\nAhora, hacé push para enviar los commits al repositorio remoto utilizando el botón con la flecha verde apuntando hacia arriba."
  },
  {
    "objectID": "presentacion.html#haciendo-cambios-remotos",
    "href": "presentacion.html#haciendo-cambios-remotos",
    "title": "Desarrollando Software en Comunidad",
    "section": "Haciendo cambios remotos",
    "text": "Haciendo cambios remotos\n\nEn la página principal, hacé click en el botón verde que dice “Add a README”.\nAgregá algo en el archivo. Los README suelen estar escritos en Markdown y contienen información sobre el repositorio.\nAl final de la página añadí un mensaje y hacé click en “Confirm changes…”.\nVolvé a la página principal para ver el README."
  },
  {
    "objectID": "presentacion.html#obtener-cambios-remotos",
    "href": "presentacion.html#obtener-cambios-remotos",
    "title": "Desarrollando Software en Comunidad",
    "section": "Obtener cambios remotos",
    "text": "Obtener cambios remotos\n\nVolvé a RStudio.\nRevisá panel de Git.\nHacé click en la flecha azul que dice “Pull”.\nRevisá el archivo README en la pestaña Archivos."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "01_git-solo.html",
    "href": "01_git-solo.html",
    "title": "git para trabajar individualmente",
    "section": "",
    "text": "Identificar por qué el control de versiones, específicamente Git, es importante para el desarrollo de software y análisis de datos.\nDiferenciar métodos para trabajar con Git y R: integración con RStudio y usethis.\nAplicar el proceso de modificación-add-commit como el flujo de trabajo de Git para el seguimiento de los cambios y ver el historial de commits de un repositorio.\nPublicar repositorios en GitHub y coordinar versiones remotas y locales."
  },
  {
    "objectID": "01_git-solo.html#objetivos-de-aprendizaje",
    "href": "01_git-solo.html#objetivos-de-aprendizaje",
    "title": "git para trabajar individualmente",
    "section": "",
    "text": "Identificar por qué el control de versiones, específicamente Git, es importante para el desarrollo de software y análisis de datos.\nDiferenciar métodos para trabajar con Git y R: integración con RStudio y usethis.\nAplicar el proceso de modificación-add-commit como el flujo de trabajo de Git para el seguimiento de los cambios y ver el historial de commits de un repositorio.\nPublicar repositorios en GitHub y coordinar versiones remotas y locales."
  },
  {
    "objectID": "01_git-solo.html#por-qué-git",
    "href": "01_git-solo.html#por-qué-git",
    "title": "git para trabajar individualmente",
    "section": "¿Por qué git?",
    "text": "¿Por qué git?\n¿Tenés algo así en tu computadora?\n/home/pao/Documents/Clases/progrmacion\n├── script.R\n├── tp.Rmd\n├── tp_corregido.Rmd\n├── tp_corregido2.Rmd\n├── tp_final.Rmd\n├── tp_finalfinal.Rmd\n├── este_es_el_final.Rmd\n├── juro_que_esta_es_la_ultima_version_del_tp.Rmd\n└── FINAL.Rmd\nProbablemente todas las personas lo tenemos, o tuvimos algo así en algún momento, porque necesitamos guardar nuestro trabajo pero seguir teniendo acceso a versiones anteriores. Existe una solución para esto. Los sistemas de control de versiones gestionan la evolución y los cambios de un conjunto de archivos que llamaremos repositorio. Si alguna vez revisaste el historial de un archivo de Google Docs, el control de versiones es similar pero de una forma muy controlada. Git es un sistema de control de versiones muy popular, pero hay otros.\nSi trabajas de manera individual, git es genial para hacer un seguimiento de los cambios y recuperar versiones anteriores de tus archivos. También podés utilizar un repositorio remoto (que veremos más adelante) para tener una copia de seguridad y compartir tu trabajo.\nSi trabajas en equipo, podés aprovechar todo lo anterior y utilizar también el control de versiones como herramienta para colaborar y organizar las distintas versiones de un mismo archivo presentes en las múltiples computadoras que vos y las otras personas usen."
  },
  {
    "objectID": "01_git-solo.html#pero-qué-entendemos-por-control-de-versiones",
    "href": "01_git-solo.html#pero-qué-entendemos-por-control-de-versiones",
    "title": "git para trabajar individualmente",
    "section": "Pero, ¿qué entendemos por control de versiones?",
    "text": "Pero, ¿qué entendemos por control de versiones?\nImaginemos que tenemos un repositorio funcionando (más adelante veremos cómo crear uno). Cuando creas un nuevo archivo como parte del repositorio (o repo), ese archivo inicialmente no es trackeado/rastreado o no está versionado. Esto significa que git ignorará el archivo y cualquier cambio que hayas hecho hasta que lo agregues al repositorio (add en inglés) y empieces a registrar los cambios que hagas en el contenido. En ese momento el archivo está en el area staging (que podemos imagina como una sala de espera de git) y está listo para entrar en el repositorio. Para eso hay que confirmar o registrar (commit en inglés) esa versión del archivo en el repositorio. Este flujo de trabajo modify --&gt; add --&gt; commit se repetirá cada vez que quieras guardar una versión del archivo.\n\nNo recomendamos hacer un commit cada vez que guardes el archivo o cambies una coma, y tampoco es buena idea hacer un commit con mil millones de cambios. Con la práctica y dependiendo de cómo trabajes, encontrarás un punto medio cómodo.\n\n\n\n\nLa figura muestra el ciclo de cambios en un archivo: versionado o sin versional. Cuando es versionado y forma parte del repositorio, las acciones son add, commit, y modificar. Con la acción add, el archivo se “prepara”; con la acción de commit, el archivo se “guarda” en el repositorio. Este ciclo se repite cada vez que se modifica el archivo.\n\n\nMencionamos las acciones add y commit que son los nombres de dos comandos de git. Si tenes experiencia trabajando con la terminal podés utilizar git desde ahí, pero los mismos comandos pueden ejecutarse desde una GUI como GitHub Desktop o GitKraken. Durante este curso utilizaremos RStudio."
  },
  {
    "objectID": "01_git-solo.html#ya-mencionamos-repositorio-remoto",
    "href": "01_git-solo.html#ya-mencionamos-repositorio-remoto",
    "title": "git para trabajar individualmente",
    "section": "¿Ya mencionamos “repositorio remoto”?",
    "text": "¿Ya mencionamos “repositorio remoto”?\nAntes revisamos el flujo de trabajo local. El repositorio (una carpeta oculta llamada .git) vive en tu computadora y con eso ya estas usando control de versiones. Pero, también podrías conectar el repositorio local con un repositorio remoto. En este curso vamos a utilizar GitHub para alojar repositorios remotos, pero hay otras opciones que podrías explorar, como GitLab o Codeberg.\nSi usas un repositorio remoto, tendrás que agregar un paso más al flujo de trabajo local (modify --&gt; add --&gt; commit) para asegurarte que la copia del repositorio en tu computadora es la misma que la copia en GitHub y vise versa.\nLuego, otra persona de tu equipo hace un cambio en un archivo en su repositorio local y lo sube al repositorio remoto. Ahora, tu repositorio local está “desactualizado” y necesitas descargar esos nuevos commits del repositorio remoto a tu computadora. Necesitas hacer pull.\nSi luego, otra persona de tu equipo hace un cambio en un archivo en su repositorio local y lo sube al repositorio remoto. Ahora, tu repositorio local está “desactualizado” respecto del repositorio remoto. Necesitas descargar esos nuevos commits del repositorio remoto a tu computadora. Necesitas hacer pull.\n\n\n\nModelo conceptual de un flujo de trabajo utilizando proyectos RStudio y git. Los archivos se añaden al área de staging (o preparación) y luego se envían al repositorio local. Puedes enviar (push) commits al repositorio remoto y bajar (pull) nuevos commits a tu computadora.\n\n\nHerramientas como GitHub también incluyen funciones que te ayudan a colaborar y gestionar repositorios. Por ejemplo, puedes modificar archivos y hacer commits con esos cambios utilizando la interfaz web."
  },
  {
    "objectID": "01_git-solo.html#configuración-inicial",
    "href": "01_git-solo.html#configuración-inicial",
    "title": "git para trabajar individualmente",
    "section": "Configuración inicial",
    "text": "Configuración inicial\nAntes de crear tu primer repositorio es importante revisar que git esté configurado correctamente en tu computadora y que tengas permisos para modificar cosas en GitHub. Si seguiste las instrucciones instrucciones previas al curso deberías tener todo listo, pero podemos revisar el estado de situación con usethis::git_sitrep() para comprobarlo.\n&gt; usethis::git_sitrep()\n\n── Git global (user) \n• Name: \"Pao Corrales\"\n• Email: \"micorreo@gmail.com\"\n• Global (user-level) gitignore file: ~/.gitignore\n• Vaccinated: TRUE\n• Default Git protocol: \"https\"\n• Default initial branch name: \"main\"\n\n── GitHub user \n• Default GitHub host: \"https://github.com\"\n• Personal access token for \"https://github.com\": &lt;discovered&gt;\n• GitHub user: \"paocorrales\"\n• Token scopes: \"gist\", \"repo\", \"user\", and \"workflow\"\n• Email(s): \"micorreo@gmail.com (primary)\", \"paocorrales@users.noreply.github.com\", and\n  \"otro correo@gmail.com\"\nℹ No active usethis project.\nRevisá que la información sea correcta y que Personal access token for \"https://github.com\": sea igual a &lt;discovered&gt;. Eso te garantizará que puedas trabajar con git y GitHub. Si vez alguna diferencia, es útil revisar las instrucciones de instalación en “Lo que necesitas hacer antes del curso”."
  },
  {
    "objectID": "01_git-solo.html#nuevo-repositorio",
    "href": "01_git-solo.html#nuevo-repositorio",
    "title": "git para trabajar individualmente",
    "section": "Nuevo repositorio",
    "text": "Nuevo repositorio\n\nGitHub repo primero, proyecto de RStudio despues\nHay muchas formas de iniciar un nuevo repositorio, localmente en tu computadora utilizando la terminal, desde GitHub (o sus amigos) ¡o desde RStudio!. Aca te mostraremos cómo crear un repositorio desde GitHub, asociarlo a un proyecto de RStudio y trabajar con él. Pero tené en cuenta que hay muchas otras formas de trabajar con git.\n\n1. Creá un repositorio online.\n\nEntrá en github.com e inicia sesión.\nEn la esquina superior derecha, hacé click en el botón “+” y luego en “New repository”.\n\nA continuación completá la información del repositorio:\n\nRepository template: No template.\nRepository name: como quieras llamar a tu nuevo proyecto.\nDescription: Una descripción breve del proyecto. Escribila para que la entiendan personas.\nVisibilidad: Public.\nInitialize this repository with: nada (podemos configurarlo todo desde R).\n\nAntes de volver a RStudio, copia la url del repositorio. Por ejemplo https://github.com/paocorrales/myrepo.git\nYa tenés tu repositorio local!\n\n\n2. En RStudio, inicia un nuevo Proyecto:\n\nFile &gt; New Project &gt; Version Control &gt; Git. En la “URL del repositorio” pegá la URL de tu nuevo repositorio de GitHub, tiene que tener esta pinta: https://github.com/paocorrales/myrepo.git.\nElejí la carpeta en tu disco donde querés crear el proyecto.\nElejí “Open in new sesion”.\nY hacé clic en “Create project”.\n\n\nLa nueva carpeta en tu computadora será un repositorio git, vinculado a un repositorio remoto de GitHub y un proyecto de RStudio al mismo tiempo. Este flujo de trabajo también se asegura de que toda la configuración entre los repositorios local y remoto se realice correctamente.\nTambién agrega un archivo llamado .gitignore que incluye una lista de archivos que no queremos sumar al repositorio (por ejemplo .Rhistory).\n\n\nProyecto de RStudio primero, repositorio de GitHub después\nSupongamos que ya tenes un proyecto de RStudio existente y ahora que conoces todas las bondades del control de versiones queres empezar a usarlo.\nPodemos utilizar el paquete usethis para que nos ayude a empezar a versionar ese proyecto.\nPara eso, primero tenes que asegurarte de que el proyecto ya sea un repositorio git. Si tenes el tab de Git en RStudio entonces tu proyecto ya es un repositorio git. Si no lo es, podes usar la funcion usethis::use_git() para inicializarlo como un repositorio git.\n&gt; usethis::use_git()\n\n✔ Setting active project to \"/Users/yabellini/Documents/GitHub/ControlDeVersiones\".\n✔ Initialising Git repo.\n✔ Adding \".Rproj.user\", \".Rhistory\", \".Rdata\", \".httr-oauth\", \".DS_Store\", and \".quarto\" to\n  .gitignore.\nℹ There are 2 uncommitted files:\n• .gitignore\n• ControlDeVersiones.Rproj\n! Is it ok to commit them?\n\n1: Not now\n2: Negative\n3: Yes\nCuando elegimos la opcion afirmativa nos mostrara un mensaje como el siguiente:\n✔ Adding files.\n✔ Making a commit with message \"Initial commit\".\nA restart of RStudio is required to activate the Git pane.\nRestart now?\n\n1: Not now\n2: Nope\n3: Yeah\nEl siguiente paso es asociar el repositorio local con un repositorio remoto en GitHub. Para eso se usa la funcion usethis::use_github().\n&gt; usethis::use_github()\n\nℹ Defaulting to \"https\" Git protocol.\n✔ Setting active project to \"/Users/yabellini/Documents/GitHub/ControlDeVersiones\".\n✔ Creating GitHub repository \"yabellini/ControlDeVersiones\".\n✔ Setting remote \"origin\" to \"https://github.com/yabellini/ControlDeVersiones.git\".\n✔ Pushing \"main\" branch to GitHub and setting \"origin/main\" as upstream branch.\n✔ Opening URL &lt;https://github.com/yabellini/ControlDeVersiones&gt;.\nEsta funcion toma un proyecto local y realiza una serie de chequeos y acciones, entre las cuales se encuentran:\n\nVerificar que el proyecto ya es un repositorio Git.\nChequear que la rama actual es la rama predeterminada, por ejemplo, main.\nVerificar que no hay ningún origen remoto preexistente.\nCrear un repositorio asociado en GitHub.\nAñadir ese repositorio de GitHub a tu repositorio local como origen remoto.\nRealiza un push inicial a GitHub para sincronizar repos."
  },
  {
    "objectID": "01_git-solo.html#cambios-locales",
    "href": "01_git-solo.html#cambios-locales",
    "title": "git para trabajar individualmente",
    "section": "Cambios locales",
    "text": "Cambios locales\nEs hora de poner en práctica algunas de las cosas de las que hemos estado hablando.\n\nAdd, commit\n\nCreá un nuevo archivo RMarkdown y guardalo.\nAgregalo al área de preparación con add y luego hace un commit. ¡Vas a tener que pensar un mensaje descriptivo!\nHace un cambio en el archivo, puede ser cualquier cosa. Guardalo.\nRepetí el paso 2.\n\n\n\n\nPanel Git con 3 archivos sin seguimiento.\n\n\n\n\n\nPanel Git con 3 archivos con seguimiento añadidos al área de preparación.\n\n\n\n\n\nInterfaz RStudio para ver las diferencias entre archivos, escribir el mensaje para el commit y enviarlo al repositorio remoto.\n\n\n\nSi todo salió bien, empezaste a rastrear archivos, hiciste cambios y commits para guardar esa versión en el repositorio local. Puede que veas un mensaje en la pestaña de git diciendo que el repositorio local “is ahead of ’origin/master` by 2 commits”. No verás ningún cambio en GitHub hasta que hagas push y envíes esos commits al repositorio remoto. Podés hacer esto al final del día si preferis, pero si trabajas con otras personas puede ser una buena idea hacer push luego de cada commit.\n\n¡Push!\n\nAhora, hacé push para enviar los commits al repositorio remoto utilizando el botón con la flecha verde apuntando hacia arriba."
  },
  {
    "objectID": "01_git-solo.html#cambios-remotos",
    "href": "01_git-solo.html#cambios-remotos",
    "title": "git para trabajar individualmente",
    "section": "Cambios remotos",
    "text": "Cambios remotos\nVolvamos a GitHub. Si actualizas la página, ahora verás los archivos que acabas sumar al repositorio o modificar. Hagamos click en “Commits” para ver la historia del repositorio. Desde esta página, podés explorar el repositorio en el “estado” en el que estaba con cada commit y ver las diferencias entre las distintas versiones.\nAhora, podemos intentar hacer cambios aquí.\n\nCrear un README\n\nEn la página principal, hacé click en el botón verde que dice “Add a README”.\nAgregá algo en el archivo. Los README suelen estar escritos en Markdown y contienen información sobre el repositorio.\nAl final de la página añadí un mensaje y hacé click en “Confirm changes…”.\nVolvé a la página principal para ver el README.\n\n\nEl nuevo archivo y los cambios que hagas en GitHub sólo estarán en el repositorio remoto hasta que hagas un pull en el repositorio local. Si realizas cambios en el repositorio local mientras no está actualizado, podés encontrarte con conflictos cuando intentes unir las 2 versiones, lo que suele generar dolores de cabeza. Esto ocurre cuando la versión de un archivo en el repositorio local no es compatible con su versión en el repositorio remoto. En esos casos, git no puede decidir qué versión es la correcta y tenés que hacerlo vos.\nPara evitar este problema (lo más posible), tenes que hacer un pull antes de empezar a hacer cualquier otra cosa. La mayoría de las veces RStudio mostrará el mensaje “Already up to date”, pero es bueno hacerlo un hábito.\n\nPull desde GitHub\n\nVolvé a RStudio.\nRevisá panel de Git.\nHacé click en la flecha azul que dice “Pull”.\nRevisá el archivo README en la pestaña Archivos."
  },
  {
    "objectID": "01_git-solo.html#anatomía-de-un-repositorio-de-github",
    "href": "01_git-solo.html#anatomía-de-un-repositorio-de-github",
    "title": "git para trabajar individualmente",
    "section": "Anatomía de un repositorio de GitHub",
    "text": "Anatomía de un repositorio de GitHub\n\nArchivos README. Utilizá un README.md para explicar de que se trata es tu proyecto y cómo utilizarlo. README.md es el archivo que se muestra automáticamente cuando abrís un repositorio de GitHub.\nLicencia. La licencia le indica a las personas cómo puede utilizar el contenido de tu repositorio. Generalmente, utilizamos licencias permisivas para que las personas pueda utilizar los materiales de cualquier manera. Algunos ejemplos son la Licencia MIT o Apache. Podés revisar algunos recursos extra:\n\nElejí una licencia para proyectos de código.\nLicencias de software en lenguaje sencillo: explica la jerga legal de las licencias en términos sencillos\n\nGuía para colaborar. Un archivo llamado CONTRIBUTING.md que incluye las instrucciones que personas que quieren conlaborar en tu proyecto sepan lo que deben hacer si quieren ayudarte.\nCódigo de conducta. Los buenos proyectos tienen códigos de conducta para garantizar un ambiente amigable donde las personas pueden colaborar. Github tiene atajos para agregar Código de Conducta facilmente.\nIssues. Te permiten gestionar el proyecto, discutir problemas y mejoras con otras personas.\n\n\n\n\n\n\n\nMas detalle\n\n\n\nEn los talleres de Desarrollo de Paquetes de R veremos como agregar todas estas partes del repositorio en R y con foco en un paquete de R."
  },
  {
    "objectID": "02_git-equipo.html",
    "href": "02_git-equipo.html",
    "title": "Git para trabajar en equipo",
    "section": "",
    "text": "Aplicar conceptos de flujos de trabajo usando Git básicos al trabajo colaborativo utilizando GitHub.\nComprender como los conflictos de versiones se generan y como resolverlos.\nIdentificar las diferencias entre branchs y forks e identificar situaciones en las que utilizar cada una.\nComprender el uso y el rol de las branchs y los pull requests en la colaboración en un proyecto.\nGestiona pull requests como responsable o líder de un proyecto."
  },
  {
    "objectID": "02_git-equipo.html#objetivos-de-aprendizaje",
    "href": "02_git-equipo.html#objetivos-de-aprendizaje",
    "title": "Git para trabajar en equipo",
    "section": "",
    "text": "Aplicar conceptos de flujos de trabajo usando Git básicos al trabajo colaborativo utilizando GitHub.\nComprender como los conflictos de versiones se generan y como resolverlos.\nIdentificar las diferencias entre branchs y forks e identificar situaciones en las que utilizar cada una.\nComprender el uso y el rol de las branchs y los pull requests en la colaboración en un proyecto.\nGestiona pull requests como responsable o líder de un proyecto."
  },
  {
    "objectID": "02_git-equipo.html#flujo-de-trabajo-individual",
    "href": "02_git-equipo.html#flujo-de-trabajo-individual",
    "title": "Git para trabajar en equipo",
    "section": "Flujo de trabajo individual",
    "text": "Flujo de trabajo individual\nEn este capítulo vamos a ver que pinta tiene el flujo de trabajo colaborativo entre personas para hacer análisis de datos y desarrollo de software. Previamente estuviste trabajando con git de manera individual:\nModificar un archivo --&gt; Add --&gt; Commit --&gt; Push\nAsí que cada vez hagas un push, git comparará los archivos en el repositorio remoto con la versión que actualizaste localmente y actualizará el repo remoto para que todo este sincronizado. Pero cuando se trabaja con otras personas hay casos que potencialmente pueden crear conflictos de merge o versiones. Aunque el nombre sugiera lo contrario, un conflicto de merge no es necesariamente un error, ocurre cuando la versión de un archivo en el repositorio local no es compatible con su versión en el repositorio remoto. A veces, Git es capaz de combinar los dos conjuntos de cambios sin ningún problema. Pero a veces esto no es posible, y requiere que un humano intervenga y decida cómo deben combinarse los múltiples cambios, ¿mantiene la versión A, la versión B o una combinación de ambas?"
  },
  {
    "objectID": "02_git-equipo.html#identificando-conflictos-de-versiones",
    "href": "02_git-equipo.html#identificando-conflictos-de-versiones",
    "title": "Git para trabajar en equipo",
    "section": "Identificando conflictos de versiones",
    "text": "Identificando conflictos de versiones\nImaginá que alguien en tu equipo cambia el contenido de archivo R/pulgadas_a_centimetros.R para cambiar el mensaje de \"medida_pulgadas debe ser numérico.\" a \"medida_pulgadas debe ser **de tipo** numérico.\":\npulgadas_a_centimetros &lt;- function(medida_pulgadas) {\n  \n  if (!is.numeric(medida_pulgadas)) {\n    cli::cli_abort(c(\n      \"medida_pulgadas debe ser de tipo numérico.\",\n      \"i\" =  \"La variable ingresada es un {class(medida_pulgadas)[1]}.\"\n    ))\n  }\n  \n  medida_pulgadas * 2.54\n}\nAl mismo tiempo, vos también cambiaste esta línea en el código pero decidiste que el mensaje de error debe ser \"medida_pulgadas debe ser **una variable numérica**.\". Cuando intentás hacer push de la nueva versión del archivo al repositorio remoto te encontrás con este mensaje:\n&gt;&gt;&gt; /usr/bin/git push origin HEAD:refs/heads/master\nTo github.com:paocorrales/paqueteprueba.git\n ! [rejected]        HEAD -&gt; master (fetch first)\nerror: failed to push some refs to 'github.com:paocorrales/paqueteprueba.git'\nhint: Updates were rejected because the remote contains work that you do not\nhint: have locally. This is usually caused by another repository pushing to\nhint: the same ref. If you want to integrate the remote changes, use\nhint: 'git pull' before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\nEl mensaje nos aconseja hacer pull antes de intentar hacer push para actualizar el repositorio remoto. Al hacer pull nos encontramos con el siguiente problema:\n&gt;&gt;&gt; /usr/bin/git pull\nFrom github.com:paocorrales/paqueteprueba\n   6e63458..d7d2a6c  master     -&gt; origin/master\nAuto-merging R/pulgadas_a_centimetros.R\nCONFLICT (content): Merge conflict in R/pulgadas_a_centimetros.R\nAutomatic merge failed; fix conflicts and then commit the result.\nEl mensaje dice que hay conflictos con el contenido de R/pulgadas_a_centimetros.R y que el merge automático falló. La buena noticia es que ya sabemos cuál es el archivo que da problemas. Aquí, hacer commits con pequeños cambios ayuda mucho.\nAhora, si revisamos el archivo R/pulgadas_a_centimetros.R, el contenido cambió:\npulgadas_a_centimetros &lt;- function(medida_pulgadas) {\n\n  if (!is.numeric(medida_pulgadas)) {\n    cli::cli_abort(c(\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n      \"medida_pulgadas debe ser una variable numérica.\",\n=======\n      \"medida_pulgadas debe ser de tipo numérico.\",\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; d7d2a6cf0e03652e1ff52e7cf5eb2da96fe69312\n      \"i\" =  \"La variable ingresada es un {class(medida_pulgadas)[1]}.\"\n    ))\n  }\n\n  medida_pulgadas * 2.54\n}\nEstos simbolos &lt;&lt;&lt;&lt;&lt;&lt;&lt;, ======= y &gt;&gt;&gt;&gt;&gt;&gt;&gt; fueron agregados por git para resaltar el contenido que está generando conflictos. Todo lo que hay entre &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD y ======= corresponde a la versión local, y el contenido entre ======= y &gt;&gt;&gt;&gt;&gt;&gt;&gt; es la versión actualmente en GitHub. La cadena larga es el identificador del commit en Github y HEAD refiere al último commit local.\nPara arreglar el conflicto será necesario:\n\nEliminar las lineas que agrego git.\nElegir una de las 2 versiones en conflicto o generar una nueva versión que incluya todos los cambios.\nGuardar el archivo y hacer un nuevo commit, que normalmente tiene como mensaje “arregla conflicto de merge”.\n\nAlgunas herramientas como GitHub Desktop y GitKraken tienen una interfaz gráfica que permite resolver estos conflictos de manera rápida, sin embargo el mecanismo en el fondo es el mismo.\nLos conflictos de merge pueden suceder si cambiaste algo en GitHub, olvidaste hacer pull localmente y cambiaste el mismo archivo localmente. Aunque los conflictos son parte de trabajar con control de versiones, vamos a tratar de evitarlos en la medida de lo posible.\n\n1. Primero, hace pull\nEs recomendable hacer pull antes de empezar a trabajar con los archivos de un repositorio, ya que así empezarás a trabajar con la versión más actualizada del repositorio.\n\n\n2. Cada persona trabaja en archivos diferentes\nLa forma más fácil de evitar conflictos de merge es pedir a cada persona que trabaje en archivos diferentes y que no editen los archivos de otras personas. Esto funciona pero tiene limitaciones.\nA largo plazo, es posible que tengas que trabajar en el código de otra persona y, en esos casos, la comunicación entre los miembros del equipo es fundamental.\n\n\n3. Las personas se turnan\nEs posible que más de una persona esté trabajando en el mismo archivo, ya sea un script o documentación. Por lo general, ese será un trabajo para muchas personas. Una solución es turnarse: vos trabajás en el archivo por la mañana y tu compañero/a lo hace por la tarde.\n\n\n4. Las personas trabajan en branchs\nAquí es donde aprovechamos al máximo lo que git tiene para ofrecer.\nLas branchs (ramas en inglés) parecen un concepto nuevo, pero en realidad, siempre estás trabajando en una rama sin darte cuenta. La branch “predeterminada” en general se llama main porque es la principal, y todo este tiempo estuviste “agregando commits a la branch main”.\nUna branch en git es una etiqueta que apunta a un commit específico en el repositorio a partir de la cual se crean otras versiones paralelas. Trabajar en una branch te permite modificar archivos sin modificar los mismos archivos en otras branchs, porque esencialmente estás trabajando en un conjunto de archivos independientes. Cuando quieras pasar los cambios de tu branch a la branch main, tendrás que hacer un merge para combinar las ramas.\n\n\n\n“Diagrama de un árbol git que muestra la branch principal con 4 commits y una branch secundaria llamada función que comienza desde el commit 2 en la branch main y tiene 2 nuevos commits, independientes de la principal.”\n\n\nHay diferentes formas de utilizar branchs Quizás cada persona del equipo tiene una branch y trabaja en ella hasta que llega el momento de hacer un merge a la branch main. O quizás, y esto es más común, cada branch represente un nuevo desarrollo que se agrega al paquete. Por ejemplo, si agregás una nueva función, creás una branch, desarrollas el código y luego hacer un merge para incorporar la función al paquete.\nTrabajar con branchs no eliminará los conflictos del todo. Es posible que estos aparezcan cuando intentes hacer merge entre tu branch con la branch principal. Pero esto pasará una sola vez y solo cuando lo decidas.\nAntes de revisar cómo es el flujo de trabajo con branchs, hay un nuevo concepto que debemos mencionar: un pull request o PR es una herramienta de GitHub que te permite realizar cambios en una branch y luego solicitar a quien mantiene el repositorio que fusione esos cambios en la branch principal. Los pull request pueden surgir de forks (que presentaremos más adelante) o de branchs independientes dentro del repositorio. Permiten a quienes mantienen y colaboran en un proyecto, revisar, discutir, solicitar y aprobar los cambios y sumarlos al repositorio cuando estan listos.\n\nEscenario 1\nEste diagrama muestra el flujo de trabajo cuando se desea contribuir al repositorio utilizando branchs y además, asumimos que tenés permisos de escritura en el repositorio remoto:\n\n\nCloná el repositorio en tu computadora\nCrear una nueva branch.\nEdita archivos, agregalos y hacé commits en esa branch.\nCuando los cambios estén hechos y listos, envía un pull request al repositorio remoto para comparar tus cambios en tu branch con main.\nEl pull request es aceptado y fusionado o hay que hacer nuevos cambios (vuelve al paso 3).\nUna vez que el PR es aceptado y fusionado, la branch principal tiene ahora los cambios actualizados y ya se puede eliminar la branch donde estabas trabajando.\nEl proceso puede repetirse varias veces, en paralelo o en secuencia dependiendo del tamaño del equipo.\n\n\n\nEscenario 2\nSi no tenés permisos de escritura en el repositorio remoto, tendrás que utilizar forks. Esto es muy habitual cuando querés colaborar en un proyecto del que no formas parte.\nUn fork es una copia del repositorio de otra persona o equipo que se almacenará en tu cuenta de GitHub. Tanto el repositorio original como el fork se encuentran en GitHub, la diferencia es que puedes modificar y actualizar la versión que se encuentra en tu cuenta.\n\n\nCrear un fork del repositorio principal (si aún no lo tenés).\nCloná el repositorio en tu computadora.\nCrear una nueva branch en tu copia del repositorio.\nRealiza ediciones y cambios en los archivos y envíalos a la branch.\nCuando esté todo listo, abrí el pull request. Si te piden nuevos cambios tendrás que volver al paso 4.\nSi el PR aceptado y fusionado, la branch principal en el repositorio principal se actualizará y la nueva branch se puede borrar.\nFinalmente podés sincronizar tu fork del repositorio con el repositorio principal."
  },
  {
    "objectID": "02_git-equipo.html#cómo-trabajar",
    "href": "02_git-equipo.html#cómo-trabajar",
    "title": "Git para trabajar en equipo",
    "section": "Cómo trabajar",
    "text": "Cómo trabajar\nUn reto que surge a menudo es saber cómo y cuándo usar branchs. ¿Hacés todos cambios cambios allí y luego abris un PR a la branch main? ¿creás una branch, haces PR y y la borras inmediatamente después? ¿Qué cambios haces en la nueva branch? La respuesta a estas preguntas dependen del contexto, del equipo, del paquete en el que estés trabajando, de cuáles sean tus objetivos para el paquete, etc. Sin embargo, te damos algunos consejos:\n\nCuando haces cambios pequeños y enfocados con un error u objetivo específico (por ejemplo, actualizar la documentación para arreglar un error de tipeo) creá un nueva branch y abrí un PR. Cuanto más pequeños sean los cambios más fácil será revisarlos y aceptarlos.\nSi hacés grandes cambios, lo mejor es que estén relacionados a un problema u objetivo, de modo que al revisar el PR sea más fácil seguirlo y entenderlo. Dividí tus contribuciones por problema u objetivo.\nHaz cambios relacionados con un issue específico y agregá comentarios en el issue para mantener a todo el mundo al tanto.\n\nVamos a mostrar algunos ejemplos de cómo utilizar los flujos de trabajo que vimos recién en distintas situaciones.\n\nDesarrollando software de manera individual En este caso, probablemente tengas que pensar si tenés que hacer una branch, ya que podés trabajar fácilmente con git sin hacer nunca una branch. Sin embargo, si quisieras experimentar con el código (o texto) sin modificar la branch main, estarás en el escenario 1.\nDesarrollando software de manera individual pero otras personas colaboran Si estás trabajando en un paquete R de código abierto y hay personas que ocacionalmente contribuyen a tu paquete, como resposanble de mantenerlo y desarrollarlo recibirás issues y PR que tendrás que revisar y responder. En este caso es muy importante utilizar branches para reducir la posibilidad de que hagas un cambio en main que puedan afectar a usuarios de tu paquete.\nColaborando en un proyecto del que no sos parte Si contribuís ocasionalmente con un paquete de R, tendrás que usar el flujo de trabajo del escenario 2. Tendrás que hacer un fork del repositorio del paquete, hacer cambios en nuevas branchs, y abrir PR para proponer esos cambios en el paquete. Este escenario es el más habitual en el mundo de los paquetes R de código abierto, ya que la mayoría de los paquetes son mantenidos por una o varias personas.\nComo miembro de un equipo Si tenés permisos de escritura en el repositorio y formás parte de un equipo que trabaja en ese repositorio, podés trabajar siguiendo el flujo de trabajo en el escenario 1. Harás cambios en los archivos creando primero una branch y, cuando el cambio esté listo, enviarás los cambios al repositorio remoto abriendo un PR para que otras personas en el equipo puedan revisar tu propuesta.\n\n\n¿Qué flujo de trabajo necesitan estas situaciones?\nConsiderá estas situaciones y decidí que flujo de trabajo que utilizarías para cada una de ellas.\n\nEstás en una clase en la que una de las tareas es un trabajo en grupo para crear un paquete de software. ¿Cuál de los flujos de trabajo anteriores será el mejor enfoque para completar un proyecto en equipo? ¿Se te ocurren otros enfoques que puedan funcionar igual de bien? ¿Qué ¿Cuáles son los puntos fuertes y débiles de cada enfoque?\nUn amigo/a se entera de que estás creando un paquete R en tu tiempo libre y quiere contribuir. ¿Qué instrucciones le darías a tu amigo/a para que pueda contribuir? ¿Qué enfoque funcionaría mejor para vos?\nMientras navegás por la página web de un paquete de R, encontrás algunos errores de tipeo y decidís arreglarlos. ¿Cuál de los enfoques anteriores utilizarías?\n\n\n\nPlantemos árboles!\nComo ejemplo y ejercicio colaboraremos con la recientemente abierta galeria de arte Flametree, y haremos PRs en el camino.\n\nFork del repositorio\n\nIngresá a github.com/paocorrales/flametree_gallery\nHacé un fork del repositorio utilizando el botón “Fork” de la esquina superior derecha.\n\n\n\n\nCaptura de pantalla de un repositorio mostrando dónde está el botón “Fork”.\n\n\nAhora tenés una copia del repositorio en tu cuenta de GitHub.\n\nCopia la url del repositorio y clónalo en tu computadora siguiendo las instrucciones para crear un nuevo repositorio que vimos en la sección de git trabajando de manera individual.\n\n\n\n\nCaptura de pantalla de un repositorio forkeado mostrando dónde copiar la url para clonar el repositorio.\n\n\n\nAhora tenés un proyecto RStudio (que también es un repositorio) que es una copia del que está en el repositorio original. Es un proyecto muy pequeño con unos pocos archivos. template_script.R incluye el código necesario para crear bellas imágenes como ésta:\n\n\n\nImagen de árboles creada con R\n\n\nUtiliza el paquete de R flametree creado por Danielle Navarro. No vamos a discutir en profundidad cómo funciona este paquete, pero es una buena excusa para practicar pull requests.\n\nHacé un cambio en el repositorio\n\nHacé una copia del archivo template_script.R y cámbiale el nombre a &lt;tu-nombre.R&gt;\nCambiá el valor de las 3 primeras variables del script:\n\n\nname: tu nombre.\nseed: porque hay cosas aleatorias en el código.\nshades: elegí 4 colores que te gusten.\n\nPodés ejecutar el código si querés ver tu árbol (necesitarás instalar el paquete).\n\nGuardá el archivo, add al área de preparación y hacé un commit (incluí sólo el archivo .R que creaste).\nHacé push a tu repositorio remoto.\n\n\nHasta este punto hiciste el cambio en tu repositorio local (que es una copia del repositorio principal) y subiste esos cambios a tu repositorio remoto en GitHub. El repositorio original no se enteró de estos cambios porque hasta este punto todo el trabajo lo hiciste en tu repositorio.\nSi querés contribuir con los cambios que hiciste (el archivo .R con el código para crear tu árbol) en el repositorio original, es hora de hacer un pull request.\n\nHacé un pull request\n\nEntrá a tu repositorio en GitHub, ahí encontrarás tu último commit y un mensaje como este:\n\n\n\n\nCaptura de pantalla de un repositorio bifurcado en GitHub con un nuevo commit. Muestra cómo iniciar un nuevo pull request.\n\n\n\nHacé click en “Open pull request”.\nY hacé click en “Create pull request”.\nAhora completá el pull request con un título y un mensaje y luego termina el PR.\n\n\n\n\nCaptura de pantalla de GitHub que muestra cómo añadir un título, un mensaje y finalizar un pull request\n\n\n¡Listo!\n\nQuien esté a cargo del repositorio recibirá un correo electrónico. Pueden revisar el pull request, hacer comentarios y, finalmente, aceptar la contribución. Cuando esto ocurra, los cambios que hayas hecho aparecerán en el repositorio.\n\n¿En que escenario trabajamos recién? ¿Cuáles serían la diferencias con el otro escenario?\n\nTODO: usethis y git"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hola 👋",
    "section": "",
    "text": "Es un curso de 2 encuentros de 2 horas cada uno sobre cómo utilizar Git y GitHub para desarrollar de forma colaborativa software de código abierto con R, es decir, paquetes de R!\nLa primera versión de estos materiales fue desarrolada para el curso An R reproducibility toolkit for the practical researcher, se adaptó para para el programa de Campeones y Campeonas de rOpenSci en 2023 y 2024, tambien para RLadies Salzburg en 2024. Algunos de los materiales tambien son parte de la materia Introduccion a la Programacion II, de la carrera en Ciencia de Datos de la Universidad Austral.\nAntes del curso, por favor, visita la sección “Preparación” y seguí las instrucciones. Necesitarás instalar y configurar git y GitHub para participar activamente en el curso.\n\n\n\nIlustración de Alison Horst\n\n\n\nInstructoras/es\nPaola Corrales: Fue campeona en el programa de campeones de rOpenSci en 2023. Es formadora e instructora de The Carpentries y parte de su directorio. Forma parte de R-Ladies, R Forwards y LatinR. Ahora en Ingeniera de Software para la investigación aplicada al estudio del clima y el tiempo.\nYanina Bellini Saibene: Community manager de rOpenSci. Formadora e instructora de The Carpentries y presidenta de su directorio. Tambien es instructora certificada de RStudio. Es parte del directorio de R-Ladies y del Comite de Infraestructura del RConsortium. Co-Chair de LatinR. Docente de la Universidad Austral.\nElio Campitelli: Investiga sobre el hielo marino en la Universidad Monash en Melbourne Australia. Instructore de The Carpentries y por segunda vez mentore en el programa de campeones y campeonas de rOpenSci. Desarrolla paquetes de R en su tiempo libre.\n\n\nLicencia\n Todos los materiales de este curso están bajola licencia &lt;a rel=“license” href=“https://creativecommons.org/licenses/by-sa/4.0/deed.es_ES”&gt;Creative Commons Attribution-ShareAlike 4.0 International License."
  },
  {
    "objectID": "preparacion.html",
    "href": "preparacion.html",
    "title": "Lo que necesitas hacer antes del curso",
    "section": "",
    "text": "Por favor sigue estas instrucciones para asegurarte que tienes todo lo necesario para el curso.\nPosiblemente tengas instalada algunas de las herramientas, si hace mucho que no las usas, asegurate de actualizarlas."
  },
  {
    "objectID": "preparacion.html#instalá-r-y-rstudio",
    "href": "preparacion.html#instalá-r-y-rstudio",
    "title": "Lo que necesitas hacer antes del curso",
    "section": "Instalá R y RStudio",
    "text": "Instalá R y RStudio\nVamos a utilizar R (lenguaje de programación) y RStudio como IDE (Integrated Development Environment). Si no los tenés instalados, por favor seguí las instrucciones en esta página de Posit (en Ingles) para hacerlo."
  },
  {
    "objectID": "preparacion.html#instalá-git",
    "href": "preparacion.html#instalá-git",
    "title": "Lo que necesitas hacer antes del curso",
    "section": "Instalá Git",
    "text": "Instalá Git\nGit es una herramienta para control de versiones, vamos a utilizarla para trabajar colaborativamente.\nEn la pagina de Git podrás descargar el instalador para tu sistema operativo.\nEn esa misma pagina hay una guia de instalacion para cada sistema operativo en castellano."
  },
  {
    "objectID": "preparacion.html#creá-una-cuenta-en-github",
    "href": "preparacion.html#creá-una-cuenta-en-github",
    "title": "Lo que necesitas hacer antes del curso",
    "section": "Creá una cuenta en GitHub",
    "text": "Creá una cuenta en GitHub\nGitHub es una de las interfaces y repositorios mundiales mas conocidos y utilizados por quienes desarrollan software. Vamos a utilizarlo para publicar nuestro código.\n\nEntrá a https://github.com/.\nHace click en Registrarse or Sign up.\nSeguí las indicaciones para crear la cuenta personal.\nUno de los pasos implica chequear que sos una persona y luego validar la direccion de email que usaste para crear la cuenta."
  },
  {
    "objectID": "preparacion.html#configuración-de-git-y-github",
    "href": "preparacion.html#configuración-de-git-y-github",
    "title": "Lo que necesitas hacer antes del curso",
    "section": "Configuración de Git y GitHub",
    "text": "Configuración de Git y GitHub\nAhora que ya tenés git instalado y una cuenta en GitHub, es importante completar la configuración necesaria para que puedas trabajar. Hay varias maneras de hacerlo, en este caso lo haremos desde R usando el paquete usethis y gitcreds.\n\nAbrí RStudio e instalá usethis corriendo el siguiente código en la consola:\n\ninstall.packages(\"usethis\")\n\nConfigurá tu nombre y correo electrónico:\n\nusethis::use_git_config(user.name = \"Juan Perez\",\n               user.email = \"juan@ejemplo.org\")\nSustituyéndolo por tu nombre y el correo electrónico asociado a tu cuenta de GitHub. git usará esta información para registrar quien hizo cambios en un archivo. Veremos esto durante los talleres de git y Github, desarrollo de paquetes y revision de código.\n\nConfigurá tu PAT\n\nEl PAT o “personal access token”, mejor conocido como token es una especie de contraseña que deberás setear en tu computadora para poder hacer cambios en GitHub.\nPrimero tendrás que crear el token:\nusethis::create_github_token()\nSe abrirá la ventana de GitHub y ahí tendrás que seguir los pasos para crear el token y copiarlo (muy importante!). Por las dudas no cierres esta ventana.\nAhora corré el siguiente código para setear el token en tu computadora:\ngitcreds::gitcreds_set()\nElegí crear/guardar el token. Si tenés Ubuntu esto no termina acá, tendrás que seguir los pasos en esta guia para guardar el token de manera permanente.\n\nVacuná tu instalación de git:\n\nusethis::git_vaccinate() \nEsta función agrega algunos archivos y configuraciones que se consideran buenas prácticas. Vamos a ver mas detalle durante el taller de desarrollo de paquetes. También podés leer la documentación de la función para aprender más.\n\nChequeá que todo esté en orden:\n\nusethis::git_sitrep() \nEsta función devuelve el estado de situación de tu configuración de git y GitHub. Revisá que aparezca tu nombre y mail, que aparezca Vaccinated: TRUE y que Personal access token for \"https://github.com\": &lt;discovered&gt; esté tal cual ese mensaje."
  }
]